Здравствуйте, давайте создадим игру на Python. Мы будем создавать простую игру-змейку, используя библиотеку pygame.

Вспомните старые времена, когда все играли в культовую игру про змей. Давайте возродим те старые времена и построим их самостоятельно! Итак, в этом уроке мы будем создавать эту культовую игру.

Итак, приступим к созданию нашей игры. Мы будем делать это шаг за шагом, чтобы получить четкое представление о каждой части игры и ее назначении в нашей игре! Итак, приступим:

Импорт библиотек
Прежде всего, нам нужно импортировать библиотеки в наш код, который будет использоваться для сборки игры. Для сборки и запуска игры нам понадобятся указанные ниже библиотеки.

import pygame
import time
import random
pygame: эта библиотека поможет нам получить все графические компоненты для сборки игры.

random: эта библиотека поможет нам создавать еду в случайных местах в игре.

время: Это помогает нам использовать в игре функции, связанные со временем, например скорость змейки.

Запуск игры и настройка графики
Теперь приступим к созданию самой части игры. Сначала мы инициализируем игру, чтобы у нас было окно, в котором будет проходить игра.

pygame.init()
Затем мы хотели бы определить цвета, которые мы будем использовать в игре, с помощью обозначений RGB. Получите коды RGB из Интернета и поместите их в качестве координат для цветовых переменных. Мы определили 6 цветов в нашей игре, но вы можете использовать любой цвет по вашему выбору. Убедитесь, что цветовые комбинации подходят для игры.

white = (255, 255, 255)
yellow = (255, 255, 102)
black = (0, 0, 0)
red = (213, 50, 80)
green = (0, 255, 0)
blue = (50, 153, 213)
Затем мы должны определить размер дисплея, на котором будет работать наша игра. Итак, в этом случае мы должны определить высоту 600 пикселей и ширину 800 пикселей.

width = 800
height = 600
Затем мы установим наш дисплей с заданными переменными ширины и высоты в качестве входных данных, и мы опишем имя игры, которое будет отображаться в качестве заголовка для нашей игры.

dis = pygame.display.set_mode((width, height))
pygame.display.set_caption(‘Shubham Snake Game’)
Определение переменных, используемых в игре
Теперь мы инициализируем нашу переменную часов, которая будет использовать пакет времени, который мы импортировали ранее. Эта переменная «часы» позаботится обо всех связанных со временем запросах в нашем полном коде.

clock = pygame.time.Clock()
Теперь давайте определим скорость нашей змеи, а также размер блока змеи, то есть ширину змеи. Это полностью основано на выборе пользователя, и я также выбрал некоторые числа, которые, как мне показалось, подходят для игры.

snake_block = 10
snake_speed = 12
Далее мы описываем размер шрифта и стиль шрифта для отображения результатов и для отображения другой информации, например, для уведомления о том, что вы проиграли игру или хотите сыграть снова.

font_style = pygame.font.SysFont(“bahnschrift”, 25)
score_font = pygame.font.SysFont(“comicsansms”, 35)
Определение вспомогательных функций
Здесь нам нужно определить три вспомогательные функции для следующих целей: - для отображения счета, для обработки змейки и для обработки отображения другой важной информации в игре соответственно.

Итак, сначала мы определяем функцию, которая поможет нам с отображением партитуры. Мы определим позицию, в которой он будет отображаться в игре, и как он будет отображать счет.

Приведенная ниже функция принимает счет как параметр, который она отображает. Мы посчитаем счет позже в нашей программе.

def Your_score(score):
    value = score_font.render("Your Score: " + str(score), True, yellow)
    dis.blit(value, [0, 0]
Далее мы будем определять нашу змею. Без змеи наша игра не имеет значения. Итак, давайте сделаем самую важную часть нашей игры - змею. Мы определим цвет и положение змеи и ее размер, то есть snake_block.

Приведенная ниже функция принимает в качестве входных данных snake_block и snake_list. Мы определим snake_list после включения в нашей программе. Так что не волнуйтесь, если сейчас вы ничего не получите должным образом.

def our_snake(snake_block, snake_list):
 for x in snake_list:
 pygame.draw.rect(dis, black, [x[0], x[1], snake_block, snake_block])
Следующей и последней нашей вспомогательной функцией будет отображение любого сообщения, которое нам нужно показать пользователю, играющему в нашу игру.

Эта вспомогательная функция принимает в качестве входных параметров сообщение msg и цвет. Мы установим шрифт, а затем отобразим сообщение нужного цвета. Нам нужно будет указать позицию, в которой сообщение будет отображаться на игровом дисплее.

def message(msg, colour):
 mesg = font_style.render(msg, True, colour)
 dis.blit(mesg, [width / 6, height / 3])
Создание игрового цикла
Теперь мы начинаем создавать компоненты игры, которые заставят ее работать и реагировать на ввод данных пользователем с клавиатуры.

Начнем с определения двух логических переменных: game_over и game_close. Они будут описывать состояния игры.

Первый скажет игре, закончилась она или нет. Следующая переменная определяет, закрыта ли игра и нам нужно играть снова или нет. Мы определяем оба как ложные.

game_over = False
game_close = False
На следующем этапе мы стремимся определить другие переменные, которые нам понадобятся в игре.

Мы будем определять x1 и y1 для обозначения положения змеи в нашей игре. Мы инициализируем их ширину / 2 и высоту / 2 соответственно. Кроме того, мы будем определять переменные x1_change и y1_change, которые будут использоваться для обозначения изменений положения змеи на основе ввода, предоставленного пользователем.

x1 = width / 2
 y1 = height / 2
 
 x1_change = 0
 y1_change = 0
Кроме того, нам необходимо определить переменные snake_List и snake_length для хранения всех положений головы змеи и длины змеи соответственно.

snake_List = []
snake_length = 1
Нам также необходимо инициализировать позицию, в которой еда будет появляться в нашей игре каждый раз после того, как она будет съедена змеей. Мы воспользуемся библиотекой random, чтобы помочь нам определить позицию блюда.

foodx = round(random.randrange(0, width — snake_block) / 10.0) * 10.0
foody = round(random.randrange(0, height — snake_block) / 10.0) * 10.0
Затем мы запустим цикл, который будет выполняться до тех пор, пока game_over не станет True.

Внутри этого цикла мы сначала определяем инструкции, которые будут выполняться в случае, если переменная game_close имеет значение True.

Ниже приведен код, который поможет нам справиться с этой ситуацией, когда game_close равно True.

while game_close == True:
 dis.fill(blue)
 message(“Oops! Your snake died! Press P to play again or Q to quit”, red)
 Your_score(snake_length — 1)
 pygame.display.update()
 
 for event in pygame.event.get():
   if event.type == pygame.KEYDOWN:
     if event.key == pygame.K_q:
       game_over = True
       game_close = False
     if event.key == pygame.K_p:
       gameLoop()
Как вы видите выше, мы определили многое. Заливаем дисплей синим цветом (обязательно можете выбрать свой). Затем мы отображаем сообщение, показывающее, что человек проиграл игру, и мы должны спросить, хочет ли этот человек сыграть в нее снова или выйти из игры.

Мы также отображаем оценку пользователя, равную длине змеи минус 1. Мы обновляем счет на 1 каждый раз, когда наша змея ест еду.

Теперь, чтобы принять пользовательский ввод относительно того, хочет ли он снова играть или выйти из него, мы определяем цикл for. Когда мы попросили пользователя внести свой вклад в его решение, мы определяем наши возможности для ввода.

Если пользователь вводит ‘p’, мы просто продолжаем наш игровой цикл. Если пользователь вводит ‘q’, нам нужно выйти из игры.

Теперь, после обработки условия game_close, мы должны определить все необходимые шаги, которые позволят нашей змейке перемещаться под действием пользователя. Мы принимаем комбинации клавиш W, A, S, D и клавиши вверх, вниз, влево и вправо для игры. Вы можете свободно выбирать ключи для игры.

for event in pygame.event.get():
 if event.type == pygame.QUIT:
   game_over = True
 if event.type == pygame.KEYDOWN:
   if event.key == pygame.K_LEFT or event.key == pygame.K_a:
     x1_change = -snake_block
     y1_change = 0
   elif event.key == pygame.K_RIGHT or event.key == pygame.K_d:
     x1_change = snake_block
     y1_change = 0
   elif event.key == pygame.K_UP or event.key == pygame.K_w:
     y1_change = -snake_block
     x1_change = 0
   elif event.key == pygame.K_DOWN or event.key == pygame.K_s:
     y1_change = snake_block
     x1_change = 0
В приведенном выше коде мы изменяем значения x1_change и y1_change в соответствии с данными, введенными пользователем. Также мы выходим из игры, если пользователь хочет выйти из игры.

Затем мы определим условие проигрыша игры. Кроме того, мы обновляем значения x1 и y1 с помощью x1_change и y1_change. Мы также заполняем весь дисплей синим цветом и рисуем змею и еду, передавая положение их появления на дисплее.

 if x1 >= width or x1 < 0 or y1 >= height or y1 < 0:
    game_close = True
 x1 += x1_change
 y1 += y1_change
 dis.fill(blue)
 pygame.draw.rect(dis, green, [foodx, foody, snake_block, snake_block])
Затем мы определяем список, известный как snake_Head, который будет хранить значения головы змеи после каждой итерации. Добавляем к нему значения x1 и y1. Затем мы добавляем этот snake_Head в snake_List.

Затем мы проверяем условие: не превышает ли длина snake_List snake_length. Если да, удалите первый элемент в snake_List.

Затем мы проверяем, совпадает ли текущий snake_Head с каким-либо из элементов snake_List, кроме того, который добавлен недавно, то есть проверяемого snake_Head. Если да, то закрываем игру, и игрок проигрывает.

Это связано с тем, что появление snake_Head в snake_List означает, что он был добавлен в snake_List раньше, и обнаружение того же значения снова означает, что змея кусает себя. Значит, в этот момент игрок должен проиграть.

Затем мы вызываем функции our_snake и Your_score (определенные ранее) и передаем необходимые параметры этим функциям, чтобы отобразить обновленную змею и счет игрока.

 snake_Head = []
 snake_Head.append(x1)
 snake_Head.append(y1)
 snake_List.append(snake_Head)
 if len(snake_List) > snake_length:
   del snake_List[0]
 
 for x in snake_List[:-1]:
   if x == snake_Head:
     game_close = True
 
 our_snake(snake_block, snake_List)
 Your_score(snake_length — 1)
 
 pygame.display.update()
Затем мы сформируем новую пищу после того, как змея съела предыдущую. Итак, для этого нам нужно найти новую случайную позицию на дисплее, чтобы создать еду. Также нам нужно увеличить длину змеи на 1, так как она только что съела еду.

Далее мы передаем скорость змейки в качестве параметра для часов. отметьте, что запускает игровой цикл.

if x1 == foodx and y1 == foody:
  foodx = round(random.randrange(0, width — snake_block) / 10.0) * 10.0
  foody = round(random.randrange(0, height — snake_block) / 10.0) * 10.0
  snake_length += 1
 
clock.tick(snake_speed)
Наша игра почти закончена. Последний шаг, нам нужно выйти из игры и снова вызвать игровой цикл.

  pygame.quit()
  quit()
gameLoop()
